% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/posterior.R
\name{fitted.brmcoda}
\alias{fitted.brmcoda}
\alias{fitted}
\title{Expected Values of the Posterior Predictive Distribution}
\usage{
\method{fitted}{brmcoda}(
  object,
  newdata = NULL,
  re_formula = NULL,
  scale = c("response", "linear", "comp"),
  summary = TRUE,
  ...
)
}
\arguments{
\item{object}{An object of class \code{brmcoda}.}

\item{newdata}{An optional data.frame for which to evaluate predictions. If
\code{NULL} (default), the original data of the model is used.
\code{NA} values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.}

\item{re_formula}{formula containing group-level effects to be considered in
the prediction. If \code{NULL} (default), include all group-level effects;
if \code{NA}, include no group-level effects.}

\item{scale}{Either \code{"response"} or \code{"linear"} or \code{"comp"}.
If either \code{"response"} or \code{"linear"},
results are returned using the corresponding method in \code{predict.brmsfit}.
\code{"comp"} is only relevant to multivariate models of class \code{mvbrmsformula}
(i.e., when response is composition). If \code{"comp"},
results are returned on the compositional scale of the response variable.}

\item{summary}{Should summary statistics be returned
instead of the raw values? Default is \code{TRUE}.}

\item{...}{Further arguments passed to \code{\link{fitted.brmsfit}}
that control additional aspects of prediction.}
}
\value{
An \code{array} of predicted \emph{mean} response values.
  If \code{summary = FALSE} the output resembles those of
  \code{\link[brms]{posterior_epred.brmsfit}}.

  If \code{summary = TRUE} the output depends on the family: For categorical
  and ordinal families, the output is an N x E x C array, where N is the
  number of observations, E is the number of summary statistics, and C is the
  number of categories. For all other families, the output is an N x E
  matrix. The number of summary statistics E is equal to \code{2 +
  length(probs)}: The \code{Estimate} column contains point estimates (either
  mean or median depending on argument \code{robust}), while the
  \code{Est.Error} column contains uncertainty estimates (either standard
  deviation or median absolute deviation depending on argument
  \code{robust}). The remaining columns starting with \code{Q} contain
  quantile estimates as specified via argument \code{probs}.

  In multivariate models, an additional dimension is added to the output
  which indexes along the different response variables.
}
\description{
Compute posterior draws of the expected value of the posterior predictive
distribution of a \code{brmsfit} model in the \code{brmcoda} object.
Can be performed for the data used to fit the model (posterior
predictive checks) or for new data. By definition, these predictions have
smaller variance than the posterior predictions performed by the
\code{\link{predict.brmcoda}} method. This is because only the
uncertainty in the expected value of the posterior predictive distribution is
incorporated in the draws computed by \code{fitted} while the
residual error is ignored there. However, the estimated means of both methods
averaged across draws should be very similar.
}
\examples{
\dontrun{
## fit a model
if(requireNamespace("cmdstanr")){
## compute composition and ilr coordinates
cilr <- compilr(data = mcompd, sbp = sbp, 
        parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

## fit a model
m1 <- brmcoda(compilr = cilr, 
              formula = STRESS ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                 wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID), 
              chain = 1, iter = 500,
              backend = "cmdstanr")
              
## compute expected predictions
fit <- fitted(m1)
head(fit)

## fit a model with compositional outcome
m2 <- brmcoda(compilr = cilr, 
              formula = mvbind(ilr1, ilr2, ilr3, ilr4) ~ STRESS + Female + (1 | ID),
              chain = 1, iter = 500,
              backend = "cmdstanr")
              
## expected responses on compositional scale
fitcomp <- fitted(m2, scale = "comp")
head(fitcomp)
}}
}
\seealso{
\code{\link[brms:fitted.brmsfit]{fitted.brmsfit}}
}
